<br/><h4>Задание 1.  </h4>
*Файл: [task1.py](https://github.com/Yakobro-coder/test_task/blob/master/tast1.py)*  

```
Example:
def isEven(value):return value%2==0
```
Плюсы:  
`- Короткий код в одну строчку:)`

Минусы:  
*Есть общепринятые правила написания python кода(PEP8), по которым в данном случае не соблюдается:* 
```
- Наименование функции должно нести смысл/логику выполняемой этой функцией.
- Наименование функции необходимо писать из маленьких букв с подчеркиванием 
  между слов(snake_case), в данном примере используется стиль camlCase.
- Имена переменных также должны описывать что хранит в себе переменная. 
- Из-за отсутствия\несоблюдения отступов и переносов строк теряется читаемость кода.
```
  
В своём исполнении(*[task1.py](https://github.com/Yakobro-coder/test_task/blob/master/tast1.py)*) я устранил описанные выше минусы:)  
Как вариант можно было расписать через if/else, но посчитал что это будет излишнее нагромождение кода,
что тоже минус.

<br/><br/><h4>Задание 2.  </h4>
*Файл: [task2.py](https://github.com/Yakobro-coder/test_task/blob/master/task2.py)*

Первый вариант, класс **BufferFifo**  
```
В данном варианте при полном заполнении циклического массива(буфера) данными, с каждым следующим 
добавленным элементом, первый(и последующие) вошедший элементы в массив будут удаляться из массива.

В таком варианте в ограниченном циклическом буфере будут только самые последние("свежие") данные
не превышающие заданный размер.
```

Второй вариант, класс **HoldBufferFifo**
```
В этом варианте, после того как циклический буфер будет заполнен, запись данных будет прервана
с целью избежать потери(перезаписи) данных.
```

<br/><br/><h4>Задание 3.  </h4>
*Файл: [task3.py](https://github.com/Yakobro-coder/test_task/blob/master/task2.py)*  

Я использовал стандартные функции python, это:  
```
- array.sort()  
- sorted(array)
```

Данные функции использую сортировку **Timsort**.<br/><br/>
Этот алгоритм сортировки сочетает в себе алгоритмы сортировки вставками и слиянием.  
Алгоритм ускоряет сортировку в случаях уже отсортированного массива, что по статистике 
чаще всего случается при сортировке данных в повседневных задачах. Самый быстрый и часто 
используемый алгоритм сортировки является "Быстрая сортировка".  

*Про сложность **O(n)** алгоритмов и виды сортировок я изучил, прочитав книгу "Грокаем алгоритмы" А. Бхаргава :)*
